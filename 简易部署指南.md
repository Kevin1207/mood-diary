# ğŸš€ è¶…ç®€å•éƒ¨ç½²æŒ‡å— - å¤åˆ¶ç²˜è´´ç‰ˆ

ç”±äºCloudflareçš„å®‰å…¨éªŒè¯ï¼Œè‡ªåŠ¨åŒ–éƒ¨ç½²å¯èƒ½ä¼šå¤±è´¥ã€‚  
**æ²¡å…³ç³»ï¼è¿™ä¸ªæŒ‡å—è®©ä½ é€šè¿‡ç®€å•çš„å¤åˆ¶ç²˜è´´å®Œæˆéƒ¨ç½²ï¼**

---

## âœ… ä½ å·²ç»å®Œæˆäº†

- âœ… åˆ›å»ºäº†D1æ•°æ®åº“
- âœ… æ•°æ®åº“IDï¼š`eb51fc89-c25d-4887-8cb3-e349c22bc18a`

---

## ğŸ“‹ ç¬¬äºŒæ­¥ï¼šéƒ¨ç½² Workerï¼ˆ5åˆ†é’Ÿï¼‰

### 1. æ‰“å¼€Cloudflare

åœ¨ä½ çš„æµè§ˆå™¨ä¸­æ‰“å¼€ï¼šhttps://dash.cloudflare.com

### 2. åˆ›å»º Worker

1. å·¦ä¾§èœå• â†’ **Workers & Pages**
2. ç‚¹å‡» **"Create application"**
3. é€‰æ‹© **"Create Worker"**
4. åç§°å¡«å†™ï¼š`mood-diary-api`
5. ç‚¹å‡» **"Deploy"**

### 3. ç¼–è¾‘ä»£ç 

1. ç‚¹å‡» **"Quick Edit"** æŒ‰é’®
2. **åˆ é™¤**ç¼–è¾‘å™¨ä¸­æ‰€æœ‰é»˜è®¤ä»£ç ï¼ˆå…¨é€‰åˆ é™¤ï¼‰
3. **å¤åˆ¶**ä¸‹é¢çš„ä»£ç ï¼š

---

### ğŸ“„ Workerä»£ç ï¼ˆå¤åˆ¶è¿™ä¸ªï¼‰

```javascript
// Cloudflare Workers API for Mood Diary
export default {
  async fetch(request, env) {
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-User-Id',
        },
      });
    }

    const url = new URL(request.url);
    const path = url.pathname;

    try {
      if (path === '/api/register' && request.method === 'POST') {
        return await handleRegister(request, env);
      } else if (path === '/api/login' && request.method === 'POST') {
        return await handleLogin(request, env);
      } else if (path === '/api/moods' && request.method === 'GET') {
        return await handleGetMoods(request, env);
      } else if (path === '/api/moods' && request.method === 'POST') {
        return await handleSaveMood(request, env);
      } else if (path.startsWith('/api/moods/') && request.method === 'DELETE') {
        return await handleDeleteMood(request, env, path);
      } else {
        return jsonResponse({ error: 'Not found' }, 404);
      }
    } catch (error) {
      console.error('Error:', error);
      return jsonResponse({ error: error.message }, 500);
    }
  },
};

async function handleRegister(request, env) {
  const { username, email, password } = await request.json();
  if (!username || !email || !password) {
    return jsonResponse({ error: 'è¯·å¡«å†™æ‰€æœ‰å­—æ®µ' }, 400);
  }
  if (username.length < 3 || username.length > 20) {
    return jsonResponse({ error: 'ç”¨æˆ·åéœ€è¦3-20ä¸ªå­—ç¬¦' }, 400);
  }
  if (password.length < 6) {
    return jsonResponse({ error: 'å¯†ç è‡³å°‘éœ€è¦6ä½' }, 400);
  }

  const existingUser = await env.DB.prepare(
    'SELECT * FROM users WHERE username = ? OR email = ?'
  ).bind(username, email).first();

  if (existingUser) {
    return jsonResponse({ error: 'ç”¨æˆ·åæˆ–é‚®ç®±å·²è¢«ä½¿ç”¨' }, 400);
  }

  const userId = crypto.randomUUID();
  const passwordHash = await hashPassword(password);

  await env.DB.prepare(
    'INSERT INTO users (id, username, email, password_hash, created_at) VALUES (?, ?, ?, ?, ?)'
  ).bind(userId, username, email, passwordHash, new Date().toISOString()).run();

  const token = await generateToken(userId);

  return jsonResponse({
    success: true,
    user: { id: userId, username, email },
    token,
  });
}

async function handleLogin(request, env) {
  const { username, password } = await request.json();
  if (!username || !password) {
    return jsonResponse({ error: 'è¯·å¡«å†™ç”¨æˆ·åå’Œå¯†ç ' }, 400);
  }

  const user = await env.DB.prepare(
    'SELECT * FROM users WHERE username = ? OR email = ?'
  ).bind(username, username).first();

  if (!user) {
    return jsonResponse({ error: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯' }, 401);
  }

  const passwordMatch = await verifyPassword(password, user.password_hash);
  if (!passwordMatch) {
    return jsonResponse({ error: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯' }, 401);
  }

  const token = await generateToken(user.id);

  return jsonResponse({
    success: true,
    user: { id: user.id, username: user.username, email: user.email },
    token,
  });
}

async function handleGetMoods(request, env) {
  const userId = await getUserIdFromRequest(request);
  if (!userId) {
    return jsonResponse({ error: 'æœªæˆæƒ' }, 401);
  }

  const moods = await env.DB.prepare(
    'SELECT * FROM moods WHERE user_id = ? ORDER BY date DESC'
  ).bind(userId).all();

  return jsonResponse({ moods: moods.results || [] });
}

async function handleSaveMood(request, env) {
  const userId = await getUserIdFromRequest(request);
  if (!userId) {
    return jsonResponse({ error: 'æœªæˆæƒ' }, 401);
  }

  const { date, mood, note } = await request.json();
  if (!date || !mood) {
    return jsonResponse({ error: 'æ—¥æœŸå’Œå¿ƒæƒ…ä¸èƒ½ä¸ºç©º' }, 400);
  }

  const existing = await env.DB.prepare(
    'SELECT * FROM moods WHERE user_id = ? AND date = ?'
  ).bind(userId, date).first();

  if (existing) {
    await env.DB.prepare(
      'UPDATE moods SET mood = ?, note = ?, updated_at = ? WHERE user_id = ? AND date = ?'
    ).bind(mood, note || '', new Date().toISOString(), userId, date).run();
  } else {
    const moodId = crypto.randomUUID();
    await env.DB.prepare(
      'INSERT INTO moods (id, user_id, date, mood, note, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)'
    ).bind(moodId, userId, date, mood, note || '', new Date().toISOString(), new Date().toISOString()).run();
  }

  return jsonResponse({ success: true });
}

async function handleDeleteMood(request, env, path) {
  const userId = await getUserIdFromRequest(request);
  if (!userId) {
    return jsonResponse({ error: 'æœªæˆæƒ' }, 401);
  }

  const date = path.split('/').pop();
  await env.DB.prepare(
    'DELETE FROM moods WHERE user_id = ? AND date = ?'
  ).bind(userId, date).run();

  return jsonResponse({ success: true });
}

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
    },
  });
}

async function hashPassword(password) {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

async function verifyPassword(password, hash) {
  const passwordHash = await hashPassword(password);
  return passwordHash === hash;
}

async function generateToken(userId) {
  const data = `${userId}:${Date.now()}:${Math.random()}`;
  const encoder = new TextEncoder();
  const encoded = encoder.encode(data);
  const hash = await crypto.subtle.digest('SHA-256', encoded);
  return Array.from(new Uint8Array(hash))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

async function getUserIdFromRequest(request) {
  const auth = request.headers.get('Authorization');
  if (!auth || !auth.startsWith('Bearer ')) {
    return null;
  }
  const userId = request.headers.get('X-User-Id');
  return userId;
}
```

---

4. **ç²˜è´´**åˆ°ç¼–è¾‘å™¨ä¸­ï¼ˆæ›¿æ¢æ‰€æœ‰å†…å®¹ï¼‰
5. ç‚¹å‡» **"Save and Deploy"**

### 4. é…ç½® D1 æ•°æ®åº“ç»‘å®šï¼ˆé‡è¦ï¼ï¼‰

1. å›åˆ° Worker è¯¦æƒ…é¡µï¼ˆå…³é—­ç¼–è¾‘å™¨ï¼‰
2. ç‚¹å‡» **"Settings"** æ ‡ç­¾
3. å·¦ä¾§èœå• â†’ **"Variables"**
4. æ‰¾åˆ° **"D1 Database Bindings"** åŒºåŸŸ
5. ç‚¹å‡» **"Add binding"**
6. å¡«å†™ï¼š
   - **Variable name**: `DB`ï¼ˆå¿…é¡»æ˜¯å¤§å†™DBï¼‰
   - **D1 database**: é€‰æ‹© `mood-diary-db`
7. ç‚¹å‡» **"Save"**

### 5. è·å– Worker URL

å›åˆ° Worker è¯¦æƒ…é¡µé¡¶éƒ¨ï¼Œå¤åˆ¶æ˜¾ç¤ºçš„URLï¼š

```
https://mood-diary-api.ä½ çš„å­åŸŸå.workers.dev
```

**æŠŠè¿™ä¸ªURLå‘Šè¯‰æˆ‘ï¼** æˆ‘ä¼šå¸®ä½ é…ç½®å‰ç«¯ã€‚

---

## ğŸ‰ å®Œæˆè¿™5æ­¥å

å‘Šè¯‰æˆ‘ä½ çš„Worker URLï¼Œæˆ‘ä¼šï¼š
1. âœ… æ›´æ–°å‰ç«¯é…ç½®æ–‡ä»¶
2. âœ… æ¨é€åˆ°GitHub
3. âœ… ä½ å°±å¯ä»¥ä½¿ç”¨äº‘ç«¯åŒæ­¥äº†ï¼

**é‡åˆ°ä»»ä½•é—®é¢˜éšæ—¶å‘Šè¯‰æˆ‘ï¼** ğŸ’ª
